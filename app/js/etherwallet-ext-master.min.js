var PrivKey = "";
var decryptType = "";
var SavedNickNames = [];
var usdval;
var eurval;
var btcval;
$(document).ready(function() {
	bindElements();
	checkAndLoadPageHash();
});
function checkAndLoadPageHash() {
	if (window.location.hash) {
		var phash = window.location.hash.substr(1);
		$(".ptabs").each(function(index) {
			if ($(this).attr('id') == phash) {
				$(this).click();
				setTimeout(function() {
					$('html,body').scrollTop(0);
				}, 50);
				return;
			}
		});
	}
}

function paneNavigate(showEleId, activeEleId) {
	hideAllMainContainers();
	$("#" + showEleId).show();
	$("#" + activeEleId).parent().addClass('active');
	location.hash = activeEleId;
	onTabOpen(activeEleId);
	$('html,body').scrollTop(0);
}

function onTabOpen(tabid) {
	if (tabid == 'add-wallet') {
		setNickNames();
	} else if (tabid == 'wallets') {
		reloadMainPageWallets();
	} else if (tabid == 'send-transaction') {
		setSendTransactionWallets();
	}
}

function bindElements() {
	$(".ptabs").each(function(index) {
		$(this).click(function() {
			paneNavigate($(this).attr('showId'), this.id);
		});
	});
	$("#btndonate").click(function() {
		$("#sendtxaddress").val('0x7cb57b5a97eabe94205c07890be4c1ad31e486a8');
		$("#donateThanks").show();
		$("#sendtxaddress").trigger("keyup");
	});
	$("#btngeneratetranaction").click(function() {
		preCreateTransaction();
	});
	$("#btnapprovesend").click(function() {
		preSendTransaction();
	});
	$("#decryptAddWallet").click(function() {
		addDecryptedWallet();
	});
    $("#btnapproveEdit").click(function(){
        var ethAccAddress = $("#editWalletAddress").val();
        var newNick = $("#walletName").val();
        editNickName(ethAccAddress,newNick,function(){
            reloadMainPageWallets();
            $("#walletName").val('');
            $("#editWallet").modal("hide");
        });
    });
    $("#btnapproveremove").click(function(){
        var ethAccAddress = $("#deleteWalletAddress").val();
        deleteAccount(ethAccAddress,function(){
            reloadMainPageWallets();
            $("#removeWallet").modal("hide");
        });
    });
	$("#transferAllBalance").click(function() {
		getMaxSendAmount($("#accountAddress1").html(), function(data) {
			$('#sendtxamount').val(data);
			$('input[type=radio][name=currencyRadio][value=ether]').prop("checked", true);
			$('#sendtxamount').trigger("keyup");
		}, function(err) {
			$("#txcreatestatus").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
		});
	});
	$("#decryptdata").click(function() {
		$("#decryptStatus").html('<p class="text-center text-info"><strong> Please Wait...</strong></p>').fadeIn(10);
		setTimeout(function() {
			decryptFormData();
		}, 100);
	});
	$("#decryptSendTx").click(function() {
		$("#decryptStatusSendTx").html('<p class="text-center text-info"><strong> Please Wait...</strong></p>').fadeIn(10);
		setTimeout(function() {
			decryptSendTxData();
		}, 100);
	});
	$("#generateNewWallet").click(function() {
		generateSingleWallet();
	});
	$('input[type=radio][name=typeOfKeyRadio]').change(function() {
		PrivKey = "";
		$('#fuploadStatus').empty();
		$('#walletfilepassword').val('');
		$('#privkeypassword').val('');
		$('.btn-file :file').val('');
		$('#manualprivkey').val('')
		$("#walletuploadbutton").hide();
		$("#walletPasdiv").hide();
		$("#divprikeypassword").hide();
		$("#addDecryptedWalletDiv").hide();
		$("#decryptStatus").hide();
		$("#selectedTypeKey").hide();
		$("#selectedUploadKey").hide();
		$("#selectedGenNewWallet").hide();
		$("#newWalletGenButtonDiv").hide();
		if (this.value == 'fileupload') {
			$("#selectedUploadKey").show();
			decryptType = "fupload";
		} else if (this.value == 'pasteprivkey') {
			$("#selectedTypeKey").show();
			decryptType = "privkey";
		} else if (this.value == 'gennewwallet') {
			$("#selectedGenNewWallet").show();
			$("#newWalletGenButtonDiv").show();
			decryptType = "newwallet";
		}
	});
	$('input[type=radio][name=currencyRadio]').change(function() {
		$("#sendtxamount").trigger("keyup");
	});
	$('#walletfilepassword').on('paste, keyup', function() {
		if ($('#walletfilepassword').val() != "") {
			$("#uploadbtntxt-wallet").show();
			$("#uploadbtntxt-privkey").hide();
			$("#walletuploadbutton").show();
		} else {
			$("#walletuploadbutton").hide();
		}
	});
	$('#sendtxamount').on('paste, keyup', function() {
		var amount = $('#sendtxamount').val();
		if ($('#sendtxamount').val() != "" && $.isNumeric(amount) && amount > 0) {
			var etherUnit = $('input[type=radio][name=currencyRadio]:checked').val();
			$("#weiamount").html('<p class="text-success"><strong>' + toWei(amount, etherUnit) + ' wei ( approximately ' + toFiat(amount, etherUnit, usdval) + ' USD/' + toFiat(amount, etherUnit, eurval) + ' EUR )</strong></p>');
		} else if ($('#sendtxamount').val() != "" && !$.isNumeric(amount)) {
			$("#weiamount").html('<p class="text-danger"><strong>Invalid amount</strong></p>');
		} else {
			$("#weiamount").html('');
		}
	});
	$('#sendtxaddress').on('paste, keyup', function() {
		if (validateEtherAddress($('#sendtxaddress').val())) {
			$("#addressvalidate").html('<p class="text-success"><strong> Address is valid</strong></p>').fadeIn(50);
		} else if ($('#sendtxaddress').val() == "") {
			$("#addressvalidate").html('');
		} else {
			$("#addressvalidate").html('<p class="text-danger"><strong> Invalid address</strong></p>').fadeIn(50);
		}
	});
	$('#privkeypassword').on('paste, keyup', function() {
		if ($('#privkeypassword').val().length > 6) {
			$("#uploadbtntxt-wallet").hide();
			$("#uploadbtntxt-privkey").show();
			$("#walletuploadbutton").show();
		} else {
			$("#walletuploadbutton").hide();
		}
	});
	$('#manualprivkey').on('paste, keyup', function() {
		$("#divprikeypassword").hide();
		$("#walletuploadbutton").hide();
		$("#uploadbtntxt-wallet").hide();
		$("#uploadbtntxt-privkey").hide();
		$("#manualprivkey").val($("#manualprivkey").val().replace(/(?:\r\n|\r|\n| )/g, ''));
		if ($('#manualprivkey').val().length == 128 || $('#manualprivkey').val().length == 132) {
			$("#divprikeypassword").show();
		} else if ($('#manualprivkey').val().length == 64) {
			$("#uploadbtntxt-wallet").hide();
			$("#uploadbtntxt-privkey").show();
			$("#walletuploadbutton").show();
		}
	});
	$('.btn-file :file').change(function() {
		if (!window.File || !window.FileReader || !window.FileList || !window.Blob) {
			alert('The File APIs are not fully supported in this browser. Please use a modern browser');
			return;
		}
		var input = $(this),
			numFiles = input.get(0).files ? input.get(0).files.length : 1,
			label = input.val().replace(/\\/g, '/').replace(/.*\//, '');
		input.trigger('fileselect', [numFiles, label]);
	});
	$('.btn-file :file').on('fileselect', function(event, numFiles, label) {
		$('#fuploadStatus').empty();
		$('#walletfilepassword').val('');
		PrivKey = "";
		file = $('.btn-file :file')[0].files[0];
		var fr = new FileReader();
		fr.onload = function() {
			try {
				if (walletRequirePass(fr.result)) {
					$("#walletPasdiv").show();
					$("#walletuploadbutton").hide();
				} else {
					$("#walletPasdiv").hide();
					$("#walletuploadbutton").show();
					$("#uploadbtntxt-wallet").show();
					$("#uploadbtntxt-privkey").hide();
				}
			} catch (err) {
				$('#fuploadStatus').append('<p class="text-center text-danger"><strong> ' + err + '</strong></p>');
			}
		};
		fr.readAsText(file);
		var input = $(this).parents('.input-group').find(':text'),
			log = numFiles > 1 ? numFiles + ' files selected' : label;
		if (input.length) {
			input.val(log);
		} else {
			if (log) {
				$('#fuploadStatus').append('<p class="text-center text-success"><strong> File Selected: ' + log + '</strong></p>');
			}
		}
	});
}

function setNickNames() {
	getAllNickNames(function(data) {
		SavedNickNames = data;
	});
}

function preSendTransaction() {
	sendTransaction($("#tasignedtx").val(), function(data) {
		$("#txsendstatus").html('<p class="text-center text-success"><strong> Transaction submitted. TX ID: ' + data + '</strong></p>');
		setWalletBalance(1);
	}, function(err) {
		$("#txsendstatus").html('<p class="text-center text-danger"><strong>' + err + '</strong></p>');
	});
	$('#sendTransaction').modal('hide');
}

function preCreateTransaction() {
	try {
		$("#tarawtx").val("");
		$("#tasignedtx").val("");
		$("#txsendstatus").html('')
		var toAddress = $('#sendtxaddress').val();
		if (PrivKey.length != 64) throw "Invalid Private key, try again";
		if (!validateEtherAddress(toAddress)) throw "Invalid to Address, try again";
		if (!$.isNumeric($('#sendtxamount').val()) || $('#sendtxamount').val() <= 0) throw "Invalid amount, try again";
		var etherUnit = $('input[type=radio][name=currencyRadio]:checked').val();
		var weiAmount = toWei($('#sendtxamount').val(), etherUnit);
		createTransaction(PrivKey, toAddress, weiAmount, function(data) {
			$("#tarawtx").val(data.raw);
			$("#tasignedtx").val(data.signed);
			$("#txcreatestatus").html('<p class="text-center text-success"><strong> Transaction generated</strong></p>').fadeIn(50);
			$("#divtransactionTAs").show();
			$("#divsendtranaction").show();
			$("#confirmAmount").html($('#sendtxamount').val());
			$("#confirmCurrancy").html(etherUnit);
			$("#confirmAddress").html(toAddress);
		}, function(err) {
			$("#txcreatestatus").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
			$("#divtransactionTAs").hide();
			$("#divsendtranaction").hide();
		});
	} catch (err) {
		$("#txcreatestatus").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
		$("#divtransactionTAs").hide();
		$("#divsendtranaction").hide();
	}
}

function getErrorText(err) {
	return '<p class="text-center text-danger"><strong> ' + err + '</strong></p>';
}

function getSuccessText(text) {
	return '<p class="text-center text-success"><strong> ' + text + '</strong></p>';
}

function setSendTransactionWallets() {
	getWalletsArr(function(wallets) {
		$("#tblsendtransactionWallets > tbody").empty();
		for (var i = 0; i < wallets.length; i++) {
			var cobj = wallets[i];
			var tblRow = '<tr><td><label><input type="radio" name="selectedWallet" value="' + cobj.addr + '">' + cobj.nick + '</label></td><td id="walBalance-' + i + '">loading</td></tr>';
			$("#tblsendtransactionWallets > tbody").append(tblRow);
			updateTableRowBalance(cobj.addr, 'walBalance-' + i);
		}
	});
}

function reloadMainPageWallets() {
	getWalletsArr(function(wallets) {
		$("#tblwalletsmain > tbody").empty();
		for (var i = 0; i < wallets.length; i++) {
			var cobj = wallets[i];
            var tblRow = getMainPageWalletRow(i+1,cobj.nick,cobj.addr);
			$("#tblwalletsmain > tbody").append(tblRow);
            setWalletBalance('MainTbl-'+(i+1));
		}
        addEditEvents();
	});
}

function updateTableRowBalance(address, rawid) {
	getBalance(address, function(result) {
		if (!result.error) {
			var bestCurAmount = getBestEtherKnownUnit(result.data.balance);
			$("#" + rawid).html(bestCurAmount.amount + " " + bestCurAmount.unit);
		}
	});
}
function addEditEvents(){
    $(".mainWalletEdit").unbind().click(function(){
        var editval = $(this).attr('editval');
        var nickname = $("#accountNickMainTbl-"+editval).html();
        var walAddress = $("#accountAddressMainTbl-"+editval).html();
        $("#walletNicknameEdit").html(nickname);
        $('#editWalletAddress').val(walAddress);
        $("#editWallet").modal("show");
    });
    $(".mainWalletDelete").unbind().click(function(){
        var deleteVal = $(this).attr('deleteVal');
        var nickname = $("#accountNickMainTbl-"+deleteVal).html();
        var walAddress = $("#accountAddressMainTbl-"+deleteVal).html();
        $("#walletNicknameDelete").html(nickname);
        $('#deleteWalletAddress').val(walAddress);
        $("#removeWallet").modal("show");
    });
}
function setWalletBalance(id) {
	getBalance($("#accountAddress" + id).html(), function(result) {
		if (!result.error) {
			var bestCurAmount = getBestEtherKnownUnit(result.data.balance);
			$("#accountBalance"+id).html(bestCurAmount.amount + " " + bestCurAmount.unit);
			getETHvalue('USD', function(value) {
                usdval = value;
				tusdval = toFiat(bestCurAmount.amount, bestCurAmount.unit, value);
				$("#accountBalanceUsd"+id).html(formatCurrency(parseFloat(tusdval),'$') + " USD");
			});
			getETHvalue('EUR', function(value) {
                eurval = value;
				teurval = toFiat(bestCurAmount.amount, bestCurAmount.unit, value);
				$("#accountBalanceEur"+id).html(formatCurrency(parseFloat(teurval),'&euro;')+ " EUR");
			});
            getETHvalue('BTC', function(value) {
                btcval = value;
				tbtcval = toFiat(bestCurAmount.amount, bestCurAmount.unit, value);
				$("#accountBalanceBtc"+id).html(tbtcval + " BTC");
			});
		} else
		      alert(result.msg);
	});
}

function formatCurrency(n, currency) {
    return currency + " " + n.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, "$1,");
}

function walletDecryptSuccess(id) {
	$("#accountAddress" + id).html(formatAddress(strPrivateKeyToAddress(PrivKey), 'hex'));
	setWalletBalance(id);
	$("#decryptStatus" + id).html('<p class="text-center text-success"><strong> Wallet successfully decrypted</strong></p>').fadeIn(2000);
	$("#walletpreview" + id).show();
}

function walletDecryptFailed(id, err) {
	$("#decryptStatus" + id).html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
	$("#walletpreview" + id).hide();
}

function addDecryptedWallet() {
	var password = $("#decryptwalletpin").val();
	var nickname = stripScriptTags($("#decryptwalletnickname").val());
	if (password == "") {
		$("#AddDecryptedWalletStatus").html(getErrorText("You must enter a PIN")).fadeIn(50).fadeOut(3000);
	} else if (password.length < 8) {
		$("#AddDecryptedWalletStatus").html(getErrorText("Your password must be at least 8 characters")).fadeIn(50).fadeOut(3000);
	} else if (nickname == "") {
		$("#AddDecryptedWalletStatus").html(getErrorText("You must enter a nickname for your wallet")).fadeIn(50).fadeOut(3000);
	} else if ($.inArray(nickname, SavedNickNames) > -1) {
		$("#AddDecryptedWalletStatus").html(getErrorText("Nickname is in use, please select different nickname")).fadeIn(50).fadeOut(3000);
	} else if (PrivKey == "" || PrivKey.length != 64) {
		$("#AddDecryptedWalletStatus").html(getErrorText("Invalid Private key try to decrypt the wallet again")).fadeIn(50).fadeOut(3000);
	} else {
		var address = formatAddress(strPrivateKeyToAddress(PrivKey), 'hex');
		var encprivkey = encryptPrivKey(PrivKey, password);
		addWalletToStorage(address, encprivkey, nickname, function() {
			if (chrome.runtime.lastError) {
				$("#AddDecryptedWalletStatus").html(getErrorText(chrome.runtime.lastError.message)).fadeIn(50).fadeOut(3000);
			} else {
				$("#AddDecryptedWalletStatus").html(getSuccessText("New Wallet Generated! " + nickname + ":" + address)).fadeIn(50).fadeOut(5000);
				setNickNames();
			}
		});
	}
}

function decryptFormData() {
	PrivKey = "";
	if (decryptType == 'fupload') {
		file = $('.btn-file :file')[0].files[0];
		var fr = new FileReader();
		fr.onload = function() {
			try {
				PrivKey = getWalletFilePrivKey(fr.result, $('#walletfilepassword').val());
				walletDecryptSuccess(0);
			} catch (err) {
				walletDecryptFailed(0, err);
			}
		};
		fr.readAsText(file);
	} else if (decryptType == 'privkey') {
		try {
			PrivKey = decryptTxtPrivKey($('#manualprivkey').val(), $("#privkeypassword").val());
			walletDecryptSuccess(0);
		} catch (err) {
			walletDecryptFailed(0, "Invalid password");
		}
	}
}

function decryptSendTxData() {
	var addr = $('input[type=radio][name=selectedWallet]:checked').val();
	var pin = $('#sendTransactionPin').val();
	if (addr == "") {
		$("#decryptStatus1").html(getErrorText("Please select a wallet")).fadeIn(50).fadeOut(3000);
	} else if (pin == "") {
		$("#decryptStatus1").html(getErrorText("Please enter the pin of the wallet")).fadeIn(50).fadeOut(3000);
	} else {
		getWalletFromStorage(addr, function(data) {
			try {
				if (!chrome.runtime.lastError) {
					PrivKey = decryptTxtPrivKey(JSON.parse(data[addr]).priv, pin);
					walletDecryptSuccess(1);
				} else {
					throw chrome.runtime.lastError.message;
				}
			} catch (err) {
				walletDecryptFailed(1, "Invalid password " + err);
			}
		});
	}
}

function hideAllMainContainers() {
	$("#paneWallets").hide();
	$("#paneAddWallet").hide();
	$("#paneWalgen").hide();
	$("#paneBulkgen").hide();
	$("#paneSendTrans").hide();
	$("#panePopContracts").hide();
	$("#paneHelp").hide();
	$("#paneContact").hide();
	$("#panePrint").hide();
	$("#wallets").parent().removeClass('active');
	$("#add-wallet").parent().removeClass('active');
	$("#bulk-generate").parent().removeClass('active');
	$("#generate-wallet").parent().removeClass('active');
	$("#send-transaction").parent().removeClass('active');
	$("#popular-contracts").parent().removeClass('active');
	$("#help").parent().removeClass('active');
	$("#contact").parent().removeClass('active');
}

function generateSingleWallet() {
	var password = $("#ethgenpassword").val();
	var nickname = stripScriptTags($("#newWalletNick").val());
	if (password == "") {
		$("#generatedWallet").html(getErrorText("You must enter a PIN")).fadeIn(50).fadeOut(3000);
	} else if (password.length < 8) {
		$("#generatedWallet").html(getErrorText("Your password must be at least 8 characters")).fadeIn(50).fadeOut(3000);
	} else if (nickname == "") {
		$("#generatedWallet").html(getErrorText("You must enter a nickname for your wallet")).fadeIn(50).fadeOut(3000);
	} else if ($.inArray(nickname, SavedNickNames) > -1) {
		$("#generatedWallet").html(getErrorText("Nickname is in use, please select different nickname")).fadeIn(50).fadeOut(3000);
	} else {
		var acc = new Accounts();
		var newAccount = acc.new();
		var address = newAccount.address;
		var encprivkey = encryptPrivKey(newAccount.private, password);
		addWalletToStorage(address, encprivkey, nickname, function() {
			if (chrome.runtime.lastError) {
				$("#generatedWallet").html(getErrorText(chrome.runtime.lastError.message)).fadeIn(50).fadeOut(3000);
			} else {
				$("#generatedWallet").html(getSuccessText("New Wallet Generated! " + nickname + ":" + address)).fadeIn(50).fadeOut(5000);
				setNickNames();
				$("#ethgenpassword").val('');
				$("#newWalletNick").val('');
			}
		});
		acc.clear();
	}
}

function stripScriptTags(str) {
	var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
	while (SCRIPT_REGEX.test(str)) {
		str = str.replace(SCRIPT_REGEX, "");
	}
	return str;
}

function openPrintPaperWallets(strjson) {
	var win = window.open("about:blank", "_blank");
	$.get('printwallets.html', function(data) {
		data = data.replace("{{WALLETJSON}}", strjson);
		win.document.write(data);
		$(win).ready(function() {
			win.document.write("<script>generateWallets();</script>");
		});
	});
}

function printQRcode() {
	var address = $("#address").val();
	var privkey = $("#privkey").val();
	var jsonarr = [];
	jsonarr.push({
		address: address,
		private: privkey
	});
	openPrintPaperWallets(JSON.stringify(jsonarr));
}

var SERVERURL = "https://rpc.myetherwallet.com/api.php";
var KRAKENAPI = "https://api.kraken.com/0/public/";
var COINMARKETCAPAPI = "https://coinmarketcap-nexuist.rhcloud.com/api/";
function getBalance(addr, callback){
    $.post( SERVERURL, { balance: addr }).done(callback);
}
function getTransactionData(addr, callback){
    $.post( SERVERURL, { txdata: addr }).done(callback);
}
function sendRawTx(rawTx, callback){
    $.post( SERVERURL, { rawtx: rawTx }).done(callback);
}
function getEstimatedGas(txobj, callback){
    $.post( SERVERURL, { estimatedGas: txobj }).done(callback);
}
function getEthCall(txobj, callback){
    $.post( SERVERURL, { ethCall: txobj }).done(callback);
}
function getETHvalueKraken(slavePair, callback){
    var prefix = "XETH";
    $.post( KRAKENAPI+"Ticker", { pair: prefix+slavePair }).done(function(data){
        callback(data['result'][prefix+slavePair]['o']);
    });
}
function getETHvalue(slavePair, callback){
    var prefix = "eth";
    slavePair = slavePair.toLowerCase();
    $.get(COINMARKETCAPAPI+prefix, function( data ) {
        callback(parseFloat(data['price'][slavePair]).toFixed(6));
    });
}
var stdTransactionGas = 21000;

function createTransaction(privkey, to, amountinwei, successcb, errorcb) {
	if (privkey.length != 64) {
		errorcb("Invalid Private key, try again");
		return;
	}
	if (!validateEtherAddress(to)) {
		errorcb("Invalid to Address, try again");
		return;
	}
	if (!$.isNumeric(amountinwei) || amountinwei <= 0) {
		errorcb("Invalid amount, try again");
		return;
	}
	var privateKey = new Buffer(privkey, 'hex');
	var address = strPrivateKeyToAddress(privkey);
	getTransactionData(address, function(data) {
		if (data.error) {
			errorcb("Error occurred: " + data.msg);
			return;
		}
		data = data.data;
		var nonce = padLeftEven(BNtoHex(new BigNumber(data.nonce)));
		var gasPrice = padLeftEven(BNtoHex(new BigNumber(data.gasprice).plus(1000000000).toDigits(1))); //adding extra 1gwei to be safer
		var gasLimit = padLeftEven(BNtoHex(new BigNumber(stdTransactionGas))); //standard 21000 per transaction
		var value = padLeftEven(BNtoHex(new BigNumber(String(amountinwei))));
		var rawTx = {
			nonce: '0x'+nonce,
			gasPrice: '0x'+gasPrice,
			gasLimit: '0x'+gasLimit,
			to: to,
			value: '0x'+value,
			data: ''
		};
		var tx = new Tx(rawTx);
		tx.sign(privateKey);
		verifyUpFrontCost(rawTx, function(estimatedCost) {
			if (estimatedCost > data.balance) {
				errorcb("You dont have enough balance in your account to process is transaction");
				return
			}
			var serializedTx = '0x' + tx.serialize().toString('hex');
			var rdata = {
				raw: JSON.stringify(rawTx),
				signed: serializedTx
			}
			successcb(rdata);
		}, errorcb);
	});
}

function createTransactionFromRaw(rawObj, privkey, successcb, errorcb) {
	if (privkey.length != 64) {
		errorcb("Invalid Private key, try again");
		return;
	}
	if (!validateEtherAddress(rawObj.from) || !validateEtherAddress(rawObj.to)) {
		errorcb("Invalid Address, try again");
		return;
	}
	if (!$.isNumeric(rawObj.value) || rawObj.value <= 0) {
		errorcb("Invalid amount, try again");
		return;
	}
	var privateKey = new Buffer(privkey, 'hex');
	var address = strPrivateKeyToAddress(privkey);
	getTransactionData(address, function(data) {
		if (data.error) {
			errorcb("Error occurred: " + data.msg);
			return;
		}
		data = data.data;
		var nonce = padLeftEven(BNtoHex(new BigNumber(data.nonce)));
		var gasPrice = padLeftEven(BNtoHex(new BigNumber(data.gasprice).plus(1000000000).toDigits(1)));
		var gasLimit = padLeftEven(BNtoHex(new BigNumber(rawObj.gas))); 
		var value = padLeftEven(BNtoHex(new BigNumber(String(rawObj.value))));
		var rawTx = {
			nonce: '0x'+nonce,
			gasPrice: '0x'+gasPrice,
			gasLimit: '0x'+gasLimit,
			to: rawObj.to,
			value: '0x'+value,
			data: '0x'+rawObj.data
		};
		var tx = new Tx(rawTx);
		tx.sign(privateKey);
		verifyUpFrontCost(rawTx, function(estimatedCost) {
			if (estimatedCost > data.balance) {
				errorcb("You dont have enough balance in your account to process is transaction");
				return
			}
			var serializedTx = '0x' + tx.serialize().toString('hex');
			var rdata = {
				raw: JSON.stringify(rawTx),
				signed: serializedTx
			}
			successcb(rdata);
		}, errorcb);
	});
}

function verifyUpFrontCost(rawTx, successcb, errorcb) {
	getEstimatedGas(rawTx, function(data) {
		if (data.error) {
			errorcb("Error occurred: " + data.msg);
		} else {
            if(new BigNumber(formatHexString(data.data, 'hex')).greaterThan(new BigNumber(formatHexString(rawTx.gasLimit, 'hex')))){
                errorcb("Gas limit is too low");
            } else {
			     var gasPrice = new BigNumber(formatHexString(rawTx.gasPrice, 'hex')).times(new BigNumber(formatHexString(rawTx.gasLimit, 'hex')));
			     successcb(gasPrice.plus(new BigNumber(formatHexString(rawTx.value, 'hex'))).toNumber());
            }
		}
	});
}

function getMaxSendAmount(address, successcb, errorcb) {
	getTransactionData(address, function(data) {
		if (data.error) {
			errorcb("Error occurred: " + data.msg);
			return;
		}
		data = data.data;
		var gasPrice = new BigNumber(data.gasprice).plus(1000000000).toDigits(1).times(stdTransactionGas);
		var maxVal = new BigNumber(String(data.balance)).minus(gasPrice);
		if (maxVal.lessThan(0)) {
			errorcb("Not enough balance to send a transaction");
		} else {
			successcb(toEther(maxVal.toString(), 'wei'));
		}
	});
}

function sendTransaction(signedRawTx, successcb, errorcb) {
	sendRawTx(signedRawTx, function(data) {
		if (data.error) {
			errorcb("Error occurred: " + data.msg);
			return;
		}
		successcb(data.data);
	});
}

function BNtoHex(bn) {
	return bn.toString(16);
}

function padLeftEven(hex) {
	if (hex.length % 2 != 0) return '0' + hex;
	else
	return hex;
}

function formatHexString(hex, format) {
	if (format == 'hex') {
		if (hex.substring(0, 2) == '0x') return hex;
		else
		return '0x' + hex;
	} else if (format == 'raw') {
		if (hex.substring(0, 2) == '0x') return hex.substring(2);
		else
		return hex;
	}
}

function fiatToWei(number, pricePerEther) {
	var returnValue = new BigNumber(String(number)).div(pricePerEther).times(getValueOfUnit('ether')).round(0);
	return returnValue.toString(10);
}

function toFiat(number, unit, multi) {
	var returnValue = new BigNumber(toEther(number, unit)).times(multi).round(5);
	return returnValue.toString(10);
}

function toEther(number, unit) {
	var returnValue = new BigNumber(toWei(number, unit)).div(getValueOfUnit('ether'));
	return returnValue.toString(10);
}

function toWei(number, unit) {
	var returnValue = new BigNumber(String(number)).times(getValueOfUnit(unit));
	return returnValue.toString(10);
}

function getValueOfUnit(unit) {
	unit = unit ? unit.toLowerCase() : 'ether';
	var unitValue = unitMap[unit];
	if (unitValue === undefined) {
		throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
	}
	return new BigNumber(unitValue, 10);
}

function getBestEtherKnownUnit(amountInWei) {
	amountInWei = String(amountInWei);
	var curUnit = 'wei';
	var tAmount = new BigNumber(amountInWei);
	for (var key in knownUnitMap) {
		if (knownUnitMap.hasOwnProperty(key)) {
			if (new BigNumber(amountInWei).greaterThan(new BigNumber(knownUnitMap[key]))) {
				curUnit = key;
				tAmount = new BigNumber(amountInWei).div(new BigNumber(knownUnitMap[key]));
			}
		}
	}
	return {
		unit: curUnit,
		amount: tAmount.toDigits(10).toString(10)
	};
}
var knownUnitMap = {
	'wei': '1',
	'kwei': '1000',
	'gwei': '1000000000',
	'szabo': '1000000000000',
	'finney': '1000000000000000',
	'ether': '1000000000000000000'
};
var unitMap = {
	'wei': '1',
	'kwei': '1000',
	'ada': '1000',
	'femtoether': '1000',
	'mwei': '1000000',
	'babbage': '1000000',
	'picoether': '1000000',
	'gwei': '1000000000',
	'shannon': '1000000000',
	'nanoether': '1000000000',
	'nano': '1000000000',
	'szabo': '1000000000000',
	'microether': '1000000000000',
	'micro': '1000000000000',
	'finney': '1000000000000000',
	'milliether': '1000000000000000',
	'milli': '1000000000000000',
	'ether': '1000000000000000000',
	'kether': '1000000000000000000000',
	'grand': '1000000000000000000000',
	'einstein': '1000000000000000000000',
	'mether': '1000000000000000000000000',
	'gether': '1000000000000000000000000000',
	'tether': '1000000000000000000000000000000'
};
function decryptPresaleKey(presaleJson, presalepass) {
	presaleJson = JSON.parse(presaleJson);
	var encSeedBytes = hexToBytes(presaleJson.encseed);
	var iv = hexToCryptoJS(bytesToHex(encSeedBytes.slice(0, 16)));
	var cipherText = hexToCryptoJS(bytesToHex(encSeedBytes.slice(16)));
	var derivedKey = sha256.pbkdf2(stringToBytes(presalepass), stringToBytes(presalepass), 2000, 16);
	var passbytes = hexToBytes(bytesToHex(derivedKey)).slice(0, 16);
	var plainText = CryptoJS.AES.decrypt({
		ciphertext: cipherText,
	}, hexToCryptoJS(bytesToHex(passbytes)), {
		iv: iv,
		mode: CryptoJS.mode.CBC,
		padding: CryptoJS.pad.Pkcs7,
	});
	var plainTextHex = cryptoJSToHex(plainText);
	plainText = hex2str(plainTextHex);
	var ethPriv = CryptoJS.SHA3(plainText, {
		outputLength: 256
	});
	var privkey = ethPriv.toString();
	if (verifyPrivKey(privkey, presaleJson.ethaddr)) return privkey;
	else
	throw "Invalid Password";
}

function decryptGethKeyV3(gethJson, password) {
	gethJson = JSON.parse(gethJson);
	if (gethJson.Crypto == null && gethJson.crypto != null) gethJson.Crypto = gethJson.crypto;
	var iv = gethJson.Crypto.cipherparams.iv;
	var cipherText = gethJson.Crypto.ciphertext;
	var bytesDerivedKey = getKDFKey(gethJson.Crypto, password);
	var bytesDerivedKey16 = hexToBytes(bytesToHex(bytesDerivedKey)).slice(0, 16);
	var decrypted = CryptoJS.AES.decrypt({
		ciphertext: hexToCryptoJS(cipherText)
	}, hexToCryptoJS(bytesToHex(bytesDerivedKey16)), {
		mode: CryptoJS.mode.CTR,
		padding: CryptoJS.pad.ZeroPadding,
		iv: hexToCryptoJS(iv)
	});
	var privkey = cryptoJSToHex(decrypted);
	if (verifyPrivKey(privkey, gethJson.address)) return privkey;
	else
	throw "Invalid Password";
}

function decryptTxtPrivKey(strkey, password) {
	if (strkey.length == 128) {
		var privatebytes = CryptoJS.AES.decrypt(strkey, password);
		var privkey = hex2str(cryptoJSToHex(privatebytes));
	} else if (strkey.length == 132) {
		var privatebytes = CryptoJS.AES.decrypt(strkey.substr(0, 128), password);
		var privkey = hex2str(cryptoJSToHex(privatebytes));
		var addressHash = strkey.substr(strkey.length - 4);
		var address = formatAddress(strPrivateKeyToAddress(privkey), 'hex');
		var generatedHash = cryptoJSToHex(CryptoJS.SHA3(address));
		if (generatedHash.substr(generatedHash.length - 4) != addressHash) throw "Invalid Password";
	} else if (strkey.length == 64) {
		var privkey = strkey;
	} else {
		throw "Error while decrypting your wallet";
	}
	return privkey;
}

function encryptPrivKey(privkey, password) {
	var genAdd = formatAddress(strPrivateKeyToAddress(privkey), 'hex');
	var addressHash = cryptoJSToHex(CryptoJS.SHA3(genAdd));
	addressHash = addressHash.substr(addressHash.length - 4);
	privkey = CryptoJS.AES.encrypt(privkey, password).toString();
	privkey = privkey + addressHash;
	return privkey;
}

function decryptEthWalletJson(ethjson, password) {
	ethjson = JSON.parse(ethjson);
	if (ethjson.locked && ethjson.private.length == 128) {
		var privatebytes = CryptoJS.AES.decrypt(ethjson.private, password);
		var privkey = hex2str(cryptoJSToHex(privatebytes));
	} else if (ethjson.locked && ethjson.private.length == 132) {
		var privatebytes = CryptoJS.AES.decrypt(ethjson.private.substr(0, 128), password);
		var privkey = hex2str(cryptoJSToHex(privatebytes));
	} else if (!ethjson.locked && ethjson.private.length == 64) {
		var privkey = ethjson.private;
	} else {
		throw "Error while decrypting your wallet";
	}
	if (verifyPrivKey(privkey, formatAddress(ethjson.address, 'raw'))) return privkey;
	else
	throw "Invalid Password";
}

function walletRequirePass(ethjson) {
	var jsonArr;
	try {
		jsonArr = JSON.parse(ethjson);
	} catch (err) {
		throw "not a valid wallet file";
	}
	if (jsonArr.encseed != null) return true;
	else if (jsonArr.Crypto != null || jsonArr.crypto != null) return true
	else if (jsonArr.hash != null && jsonArr.locked) return true;
	else if (jsonArr.hash != null && !jsonArr.locked) return false;
	else
	throw "Sorry! we dont have a clue what kind of wallet file this is.";
}

function verifyPrivKey(privkey, address) {
	if (privkey.length != 64) return false;
	if (strPrivateKeyToAddress(privkey) != address) return false;
	else
	return true;
}

function getWalletFilePrivKey(strjson, password) {
	var jsonArr = JSON.parse(strjson);
	if (jsonArr.encseed != null) return decryptPresaleKey(strjson, password);
	else if (jsonArr.Crypto != null || jsonArr.crypto != null) return decryptGethKeyV3(strjson, password);
	else if (jsonArr.hash != null) return decryptEthWalletJson(strjson, password);
	else
	throw "Sorry! we dont have any clue what kind of wallet file this is.";
}

function formatAddress(addr, format) {
	if (addr.substr(0, 2) == '0x' && format == 'raw') addr = addr.substr(2);
	if (addr.substr(0, 2) != '0x' && format == 'hex') addr = '0x' + addr;
	return addr;
}

function strPrivateKeyToAddress(privkey) {
	var public = ethUtil.privateToPublic(hexToBytes(privkey));
	return ethUtil.publicToAddress(public).toString('hex');
}

function getKDFKey(cryptoJson, password) {
	var salt = hexToBytes(cryptoJson.kdfparams.salt);
	var authArr = stringToBytes(password);
	var dklen = cryptoJson.kdfparams.dklen;
	if (cryptoJson.kdf == "scrypt") {
		var n = cryptoJson.kdfparams.n;
		var r = cryptoJson.kdfparams.r;
		var p = cryptoJson.kdfparams.p;
		var scrypt = scrypt_module_factory(33554432 * 10);
		return scrypt.crypto_scrypt(authArr, salt, n, r, p, dklen);
	} else if (cryptoJson.kdf == "pbkdf2") {
		var c = cryptoJson.kdfparams.c;
		var prf = cryptoJson.kdfparams.prf;
		var derivedKey = sha256.pbkdf2(stringToBytes(password), hexToBytes(cryptoJson.kdfparams.salt), c, dklen);
/*var derivedKey = CryptoJS.PBKDF2(password, hexToCryptoJS(cryptoJson.kdfparams.salt), {
		  keySize: dklen,
		  iterations: c,
		  hasher: CryptoJS.algo.SHA256 //this is painfully slow
	   });*/
		return derivedKey;
	}
}

function hexToCryptoJS(x) {
	return CryptoJS.enc.Hex.parse(x);
}

function cryptoJSToHex(x) {
	return CryptoJS.enc.Hex.stringify(x);
}

function validateEtherAddress(addr) {
	return addr.length == 42 && addr.substr(0, 2) == "0x" && /^[0-9A-F]+$/i.test(addr.substr(2));
}

function hex2str(hex) {
	var hex = hex.toString();
	var str = '';
	for (var i = 0; i < hex.length; i += 2)
	str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
	return str;
}

function bytesToHex(bytes) {
	for (var hex = [], i = 0; i < bytes.length; i++) {
		hex.push((bytes[i] >>> 4).toString(16));
		hex.push((bytes[i] & 0xF).toString(16));
	}
	return hex.join("");
}

function hexToBytes(hex) {
	for (var bytes = [], c = 0; c < hex.length; c += 2)
	bytes.push(parseInt(hex.substr(c, 2), 16));
	return bytes;
}

function stringToBytes(str) {
	var bytes = [];
	for (var i = 0; i < str.length; ++i) {
		bytes.push(str.charCodeAt(i));
	}
	return bytes;
}
var storage = chrome.storage.sync;
function getAllNickNames(callback){
    var nickNames = [];
    storage.get(null, function(items) {
        for (var key in items) {
            if (items.hasOwnProperty(key)) {
                var tobj = JSON.parse(items[key]);
                 if(tobj.type=='wallet')
                    nickNames.push(tobj.nick);
            }
        }
        callback(nickNames);
    });
}
function addWalletToStorage(address, encprivkey, nickname, callback){
    nickname = nickname.replace(/(<([^>]+)>)/ig,"");
    var value = {nick:nickname, priv:encprivkey, type:'wallet'};
    var keyname = address;
    var obj= {};
    obj[keyname] = JSON.stringify(value);
    storage.set(obj,callback);
}
function getWalletFromStorage(address, callback){
    storage.get(address,callback);
}
function getWalletsArr(callback){
    var wallets = [];
    storage.get(null, function(items) {
        for (var key in items) {
            if (items.hasOwnProperty(key)) {
                var tobj = JSON.parse(items[key]);
                 if(tobj.type=='wallet'){
                    tobj['addr']=key;
                    wallets.push(tobj);
                 }
            }
        }
        wallets.sort(sortByNickName);
        callback(wallets);
    });
}
function deleteAccount(address,callback){
    storage.remove(address,function(){
        callback(address);
    });
}
function editNickName(address,newNick, callback){
    newNick = newNick.replace(/(<([^>]+)>)/ig,"");
    storage.get(address, function(account) {
        var accountInfo = account[address];
        accountInfo = JSON.parse(accountInfo);
        accountInfo['nick'] = newNick;
        account[address] = JSON.stringify(accountInfo);
        storage.set(account,function(){
            callback(newNick);
        });
    });
}
function sortByNickName(a, b){
    if(a.nick < b.nick) return -1;
    if(a.nick > b.nick) return 1;
    return 0;
}

function getMainPageWalletRow(rid, nick,address){
    var str = "<tr>\
              <td>"+rid+"</td>\
              <td id=\"accountNickMainTbl-"+rid+"\">"+nick+"</td>\
              <td id=\"accountAddressMainTbl-"+rid+"\">"+address+"</td>\
              <td>\
                <strong class=\"text-success\" id=\"accountBalanceMainTbl-"+rid+"\"></strong>\
                <br />\
                <small><span id=\"accountBalanceBtcMainTbl-"+rid+"\"></span> &nbsp;&nbsp; <span id=\"accountBalanceUsdMainTbl-"+rid+"\"></span> &nbsp;&nbsp; <span id=\"accountBalanceEurMainTbl-"+rid+"\"></span></small>\
              </td>\
              <td> <a editVal='"+rid+"' class='mainWalletEdit'> Edit </a></td>\
              <td> <a deleteVal='"+rid+"' class='mainWalletDelete' class=\"text-danger\"> Remove </a></td>\
            </tr>";
    return str;
}
function getAccountInfoRow(rid,address, nick){
    var str = "<tr>\
        <td>\
        <div style='display:none;' id='accountAddressPopMB-"+rid+"'>"+address+"</div>\
          <label>"+nick+"</label>\
        </td>\
        <td id='accountBalancePopMB-"+rid+"'></td>\
      </tr>";
    return str;
}
function getQuickSendRow(rid,address, nick){
    var str = "<tr>\
        <td>\
        <div style='display:none;' id='accountAddressPopMB-"+rid+"'>"+address+"</div>\
          <label><label><input type=\"radio\" name=\"selectedWallet\" value=\""+address+"\">"+nick+"</label>\
        </td>\
        <td id='accountBalancePopMB-"+rid+"'></td>\
      </tr>";
    return str;
}
$(document).ready(function() {
	bindPopElements();
	pageBasedOnLoads();
});

function pageBasedOnLoads() {
	if ($("#popupMainAccountTbl").length) {
		reloadPopupAccounts();
		$("#popupConfirmSend").hide();
	}
}

function bindPopElements() {
	$("#popPreSend").click(function() {
		try {
			var selectedAcc = $("input[name=selectedWallet]:checked").val();
			var toAddress = $('#sendtxaddress').val();
			var sendAmount = $('#sendtxamount').val();
			if (typeof selectedAcc == 'undefined') throw "No account selected";
			if (!validateEtherAddress(toAddress)) throw "Invalid to Address, try again";
			if (!$.isNumeric(sendAmount) || sendAmount <= 0) throw "Invalid amount, try again";
			var etherUnit = $('input[type=radio][name=currencyRadio]:checked').val();
			var weiAmount = toWei(sendAmount, etherUnit);
			$("#confirmAmount").html(sendAmount);
			$("#confirmCurrancy").html(etherUnit);
			$("#confirmAddress").html(toAddress);
			$("#popupConfirmSend").show();
			$("#sendTransMain").hide();
		} catch (err) {
			$("#popwalletselectstatus").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
		}
	});
	$("#transferAllBalancePop").click(function() {
		var selectedAcc = $("input[name=selectedWallet]:checked").val();
		$('#sendtxamount').val('');
		if (typeof selectedAcc == 'undefined') {
			$("#popwalletselectstatus").html('<p class="text-center text-danger"><strong>No account selected</strong></p>').fadeIn(50).fadeOut(3000);
			return;
		}
		getMaxSendAmount(selectedAcc, function(data) {
			$('#sendtxamount').val(data);
			$('input[type=radio][name=currencyRadio][value=ether]').prop("checked", true);
			$('#sendtxamount').trigger("keyup");
		}, function(err) {
			$("#popwalletselectstatus").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
		});
	});
	$("#cancelTransaction").click(function() {
		$("#popupConfirmSend").hide();
		$("#sendTransMain").show();
	});
	$("#approveTransaction").click(function() {
		decryptAndSendTx();
	});
}

function decryptAndSendTx() {
	var addr = $('input[type=radio][name=selectedWallet]:checked').val();
	var pin = $('#sendTransactionPin').val();
	if (addr == "") {
		$("#decryptStatus1").html(getErrorText("Please select a wallet")).fadeIn(50).fadeOut(3000);
	} else if (pin == "") {
		$("#decryptStatus1").html(getErrorText("Please enter the pin of the wallet")).fadeIn(50).fadeOut(3000);
	} else {
		getWalletFromStorage(addr, function(data) {
			try {
				if (!chrome.runtime.lastError) {
					PrivKey = decryptTxtPrivKey(JSON.parse(data[addr]).priv, pin);
					var toAddress = $('#sendtxaddress').val();
					var sendAmount = $('#sendtxamount').val();
					var etherUnit = $('input[type=radio][name=currencyRadio]:checked').val();
					var weiAmount = toWei(sendAmount, etherUnit);
					createTransaction(PrivKey, toAddress, weiAmount, function(data) {
						var signedtx = data.signed;
						sendTransaction(signedtx, function(data) {
							$("#decryptStatus1").html('<p class="text-center text-success"><strong> Transaction submitted. TX ID: ' + data + '</strong></p>').fadeIn(50).fadeOut(3000,function() {
								location.reload();
							});							
						}, function(err) {
							$("#decryptStatus1").html('<p class="text-center text-danger"><strong>' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
						});
					}, function(err) {
						$("#decryptStatus1").html('<p class="text-center text-danger"><strong> ' + err + '</strong></p>').fadeIn(50).fadeOut(3000);
					});
				} else {
					throw chrome.runtime.lastError.message;
				}
			} catch (err) {
				walletDecryptFailed(1, "Invalid password " + err);
			}
		});
	}
}

function reloadPopupAccounts() {
	getWalletsArr(function(wallets) {
		$("#popupMainAccountTbl > tbody").empty();
		for (var i = 0; i < wallets.length; i++) {
			var cobj = wallets[i];
			if ($('.quicksend').length) var tblRow = getQuickSendRow(i, cobj.addr, cobj.nick);
			else if ($('.donate').length) var tblRow = getQuickSendRow(i, cobj.addr, cobj.nick);
			else if ($(".bAction").length) var tblRow = getAccountInfoRow(i, cobj.addr, cobj.nick);
			$("#popupMainAccountTbl > tbody").append(tblRow);
			setWalletBalance('PopMB-' + i);
		}
	});
}